<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum VR Explorer</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/babylonjs@8.52.0/babylon.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-loaders@8.52.0/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babylonjs/havok@1.3.11/lib/umd/HavokPhysics_umd.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <div id="transition-overlay"></div>

    <div id="hud">
        <div>
            <div id="scene-title"></div>
            <div id="scene-subtitle"></div>
        </div>
        <div id="nav-buttons">
            <button id="prevBtn" title="Previous scene">&#9664; Prev</button>
            <button id="menuBtn" title="Scene list">&#9776; Scenes</button>
            <button id="nextBtn" title="Next scene">Next &#9654;</button>
        </div>
    </div>

    <div id="info-panel" class="hidden">
        <h3 id="info-title"></h3>
        <p id="info-text"></p>
    </div>
    <button id="info-toggle" class="hud-btn" style="
        padding: 8px 16px; font-size: 14px; border: 1px solid rgba(255,255,255,0.2);
        border-radius: 6px; cursor: pointer; background: rgba(255,255,255,0.1);
        color: #fff; backdrop-filter: blur(6px);
    ">? Info</button>

    <div id="scene-menu" class="hidden"></div>

    <!-- QVR global must exist before scene scripts register against it -->
    <script>
    window.QVR = {
        scenes: [],
        register(def) { this.scenes.push(def); }
    };
    </script>

    <!-- Scene scripts (each calls QVR.register) -->
    <script src="scenes/00-hub.js"></script>
    <script src="scenes/01-bit-vs-qubit.js"></script>
    <script src="scenes/02-superposition.js"></script>
    <script src="scenes/03-measurement.js"></script>
    <script src="scenes/04-bloch-sphere.js"></script>
    <script src="scenes/05-quantum-gates.js"></script>
    <script src="scenes/06-amplitudes-phase.js"></script>
    <script src="scenes/07-interference.js"></script>
    <script src="scenes/08-multi-qubit.js"></script>
    <script src="scenes/09-entanglement.js"></script>
    <script src="scenes/10-quantum-circuits.js"></script>
    <script src="scenes/11-cnot-gate.js"></script>
    <script src="scenes/12-bell-states.js"></script>
    <script src="scenes/13-teleportation.js"></script>
    <script src="scenes/14-no-cloning.js"></script>
    <script src="scenes/15-hadamard-transform.js"></script>
    <script src="scenes/16-grovers-search.js"></script>
    <script src="scenes/17-shors-algorithm.js"></script>
    <script src="scenes/18-qft.js"></script>
    <script src="scenes/19-decoherence.js"></script>
    <script src="scenes/20-error-correction.js"></script>
    <script src="scenes/21-drug-discovery.js"></script>
    <script src="scenes/22-quantum-crypto.js"></script>
    <script src="scenes/23-quantum-ml.js"></script>
    <script src="scenes/24-quantum-internet.js"></script>
    <script src="scenes/25-timeline.js"></script>

    <!-- Boot: attach engine, utilities, and start first scene -->
    <script>
    (async function () {
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true,
        });

        // Extend QVR with engine and utilities now that Babylon is ready
        const qvr = window.QVR;
        qvr.engine = engine;
        qvr.canvas = canvas;
        qvr.currentIndex = -1;
        qvr.currentScene = null;
        qvr.xrHelper = null;

        // ── Shared utilities ───────────────────────────────────

        qvr.createStarfield = function (scene) {
            scene.clearColor = new BABYLON.Color4(0.01, 0.01, 0.04, 1);

            const starParent = new BABYLON.TransformNode("stars", scene);
            const SPS = new BABYLON.SolidParticleSystem("stars", scene, { isPickable: false });
            const starModel = BABYLON.MeshBuilder.CreatePolyhedron("s", { size: 0.02, type: 0 }, scene);
            SPS.addShape(starModel, 1500);
            starModel.dispose();
            const mesh = SPS.buildMesh();
            mesh.parent = starParent;

            SPS.initParticles = () => {
                for (let i = 0; i < SPS.nbParticles; i++) {
                    const p = SPS.particles[i];
                    const r = 30 + Math.random() * 70;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    p.position.x = r * Math.sin(phi) * Math.cos(theta);
                    p.position.y = r * Math.sin(phi) * Math.sin(theta);
                    p.position.z = r * Math.cos(phi);
                    const b = 0.3 + Math.random() * 0.7;
                    p.color = new BABYLON.Color4(b, b, b * 1.1, 1);
                    p.scaling.setAll(0.5 + Math.random() * 2);
                }
            };
            SPS.initParticles();
            SPS.setParticles();
            SPS.isAlwaysVisible = true;

            scene.onBeforeRenderObservable.add(() => {
                starParent.rotation.y += 0.00005;
                starParent.rotation.x += 0.00002;
            });

            const nebulaColors = [
                new BABYLON.Color3(0.15, 0.05, 0.3),
                new BABYLON.Color3(0.05, 0.1, 0.3),
                new BABYLON.Color3(0.2, 0.02, 0.1),
            ];
            for (let i = 0; i < 3; i++) {
                const nebula = BABYLON.MeshBuilder.CreatePlane("nebula" + i, { size: 40 + Math.random() * 30 }, scene);
                nebula.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 40,
                    30 + Math.random() * 40
                );
                nebula.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
                const mat = new BABYLON.StandardMaterial("nebMat" + i, scene);
                mat.emissiveColor = nebulaColors[i];
                mat.disableLighting = true;
                mat.alpha = 0.06 + Math.random() * 0.06;
                nebula.material = mat;
            }
            return starParent;
        };

        qvr.createLighting = function (scene) {
            const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.5;
            hemi.diffuse = new BABYLON.Color3(0.7, 0.75, 1.0);
            const point = new BABYLON.PointLight("point", new BABYLON.Vector3(3, 5, -3), scene);
            point.intensity = 0.8;
            point.diffuse = new BABYLON.Color3(0.9, 0.85, 1.0);
            return { hemi, point };
        };

        qvr.createGlow = function (scene) {
            const gl = new BABYLON.GlowLayer("glow", scene, { blurKernelSize: 32 });
            gl.intensity = 0.6;
            return gl;
        };

        qvr.createQubitSphere = function (name, diameter, color, scene) {
            const sphere = BABYLON.MeshBuilder.CreateSphere(name, { diameter, segments: 32 }, scene);
            const mat = new BABYLON.StandardMaterial(name + "Mat", scene);
            mat.diffuseColor = color;
            mat.emissiveColor = color.scale(0.3);
            mat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.6);
            mat.specularPower = 64;
            sphere.material = mat;
            return sphere;
        };

        qvr.createTextPlane = function (text, fontSize, width, scene) {
            const h = width * 0.35;
            const plane = BABYLON.MeshBuilder.CreatePlane("tp_" + Date.now() + Math.random(), { width, height: h }, scene);
            // Higher res texture for VR readability
            const texW = 1024, texH = Math.round(1024 * 0.35);
            const scaledFont = Math.round(fontSize * (1024 / 512));
            const tex = new BABYLON.DynamicTexture("dt_" + Date.now(), { width: texW, height: texH }, scene);
            const ctx = tex.getContext();
            // Dark background pill for contrast
            const pad = 12;
            ctx.fillStyle = "rgba(5, 5, 20, 0.65)";
            const metrics = (function () {
                ctx.font = "bold " + scaledFont + "px Segoe UI, system-ui, sans-serif";
                return ctx.measureText(text);
            })();
            const bgW = Math.min(metrics.width + pad * 4, texW);
            const bgH = scaledFont + pad * 2;
            const bgX = (texW - bgW) / 2;
            const bgY = (texH - bgH) / 2;
            // Rounded rect
            const r = 10;
            ctx.beginPath();
            ctx.moveTo(bgX + r, bgY);
            ctx.lineTo(bgX + bgW - r, bgY);
            ctx.quadraticCurveTo(bgX + bgW, bgY, bgX + bgW, bgY + r);
            ctx.lineTo(bgX + bgW, bgY + bgH - r);
            ctx.quadraticCurveTo(bgX + bgW, bgY + bgH, bgX + bgW - r, bgY + bgH);
            ctx.lineTo(bgX + r, bgY + bgH);
            ctx.quadraticCurveTo(bgX, bgY + bgH, bgX, bgY + bgH - r);
            ctx.lineTo(bgX, bgY + r);
            ctx.quadraticCurveTo(bgX, bgY, bgX + r, bgY);
            ctx.closePath();
            ctx.fill();
            // Text with stroke for boldness
            ctx.font = "bold " + scaledFont + "px Segoe UI, system-ui, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeStyle = "rgba(0,0,0,0.6)";
            ctx.lineWidth = 3;
            ctx.strokeText(text, texW / 2, texH / 2);
            ctx.fillStyle = "#ffffff";
            ctx.fillText(text, texW / 2, texH / 2);
            tex.update();
            tex.hasAlpha = true;
            const mat = new BABYLON.StandardMaterial("tm_" + Date.now(), scene);
            mat.diffuseTexture = tex;
            mat.emissiveTexture = tex;
            mat.opacityTexture = tex;
            mat.disableLighting = true;
            mat.backFaceCulling = false;
            mat.useAlphaFromDiffuseTexture = true;
            plane.material = mat;
            plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            return plane;
        };

        // ── XR Interactions (applied to every scene) ────────
        qvr.setupXRInteractions = function (scene, xr) {
            if (!xr || !xr.baseExperience) return;

            const DEADZONE_DEG = 5;
            const DEADZONE_RAD = DEADZONE_DEG * Math.PI / 180;
            const FLY_SPEED = 0.06;
            const VERTICAL_SPEED = 0.03;

            // ── Head-tilt flying ───────────────────────────────
            // Lean forward (pitch down) > 5° = fly in gaze direction
            // Lean back (pitch up) > 5° = fly backward
            let baseHeadPitch = null;
            let calibrated = false;

            xr.baseExperience.onStateChangedObservable.add((state) => {
                if (state === BABYLON.WebXRState.IN_XR) {
                    // Calibrate after a short delay so user settles
                    setTimeout(() => {
                        calibrated = false; // will calibrate on first frame
                    }, 1000);
                }
            });

            scene.onBeforeRenderObservable.add(() => {
                if (!xr.baseExperience.camera) return;
                const cam = xr.baseExperience.camera;

                // Get head pitch from camera rotation
                const rot = cam.rotationQuaternion;
                if (!rot) return;

                // Extract pitch (x rotation) from quaternion
                const euler = rot.toEulerAngles();
                const pitch = euler.x; // negative = looking down, positive = looking up

                // Calibrate: store neutral pitch on first frame
                if (!calibrated) {
                    baseHeadPitch = pitch;
                    calibrated = true;
                    return;
                }

                const deltaPitch = pitch - baseHeadPitch;

                // Forward: lean forward (pitch more negative than neutral)
                // Backward: lean back (pitch more positive than neutral)
                if (Math.abs(deltaPitch) > DEADZONE_RAD) {
                    const intensity = (Math.abs(deltaPitch) - DEADZONE_RAD) * 3;
                    const speed = Math.min(intensity, 1) * FLY_SPEED;
                    const direction = deltaPitch < 0 ? -1 : 1; // pitch down = forward, pitch up = backward

                    // Get forward direction from camera (horizontal only)
                    const forward = cam.getForwardRay().direction;
                    forward.y = 0;
                    forward.normalize();

                    const move = forward.scale(direction * speed);
                    cam.position.addInPlace(move);
                }
            });

            // ── Controller interactions ────────────────────────
            // Pico 4 Ultra profile: pico-4u
            // Left:  trigger, squeeze, thumbstick, x-button, y-button
            // Right: trigger, squeeze, thumbstick, a-button, b-button

            xr.input.onControllerAddedObservable.add((controller) => {
                controller.onMotionControllerInitObservable.add((mc) => {
                    const hand = mc.handedness; // "left" or "right"

                    // ── BOTH HANDS — SQUEEZE: spawn quantum particle + muzzle flash
                    const squeeze = mc.getComponent("xr-standard-squeeze");
                    if (squeeze) {
                        squeeze.onButtonStateChangedObservable.add((comp) => {
                            if (comp.pressed) {
                                const pos = controller.pointer.absolutePosition.clone();
                                const fwd = controller.pointer.forward.clone();
                                const spawnPos = pos.add(fwd.scale(0.3));

                                // Muzzle flash
                                const flash = BABYLON.MeshBuilder.CreateSphere("flash", {diameter:0.15, segments:6}, scene);
                                flash.position = spawnPos.clone();
                                const fMat = new BABYLON.StandardMaterial("fMat", scene);
                                fMat.emissiveColor = new BABYLON.Color3(1,0.8,0.3);
                                fMat.disableLighting = true;
                                flash.material = fMat;
                                let life = 1;
                                const obs = scene.onBeforeRenderObservable.add(() => {
                                    life -= 0.08;
                                    flash.scaling.setAll(life);
                                    fMat.alpha = life;
                                    if (life <= 0) {
                                        scene.onBeforeRenderObservable.remove(obs);
                                        flash.dispose(); fMat.dispose();
                                    }
                                });

                                // Quantum particle
                                const particle = BABYLON.MeshBuilder.CreateSphere("qp", {diameter:0.2, segments:12}, scene);
                                particle.position = spawnPos.clone();
                                const pMat = new BABYLON.StandardMaterial("qpMat", scene);
                                const hue = Math.random();
                                pMat.diffuseColor = new BABYLON.Color3(
                                    0.3+hue*0.7, 0.3+(1-hue)*0.5, 0.8
                                );
                                pMat.emissiveColor = pMat.diffuseColor.scale(0.4);
                                particle.material = pMat;

                                const vel = fwd.scale(0.15);
                                let pLife = 1;
                                const pObs = scene.onBeforeRenderObservable.add(() => {
                                    particle.position.addInPlace(vel);
                                    vel.scaleInPlace(0.98);
                                    pLife -= 0.008;
                                    pMat.alpha = pLife;
                                    particle.scaling.setAll(0.5 + (1-pLife)*0.5);
                                    if (pLife <= 0) {
                                        scene.onBeforeRenderObservable.remove(pObs);
                                        particle.dispose(); pMat.dispose();
                                    }
                                });
                            }
                        });
                    }

                    // ── BOTH HANDS — TRIGGER: interact with scene objects
                    const trigger = mc.getComponent("xr-standard-trigger");
                    if (trigger) {
                        trigger.onButtonStateChangedObservable.add((comp) => {
                            if (comp.pressed) {
                                const ray = new BABYLON.Ray(
                                    controller.pointer.absolutePosition,
                                    controller.pointer.forward,
                                    20
                                );
                                const hit = scene.pickWithRay(ray);
                                if (hit && hit.pickedMesh && hit.pickedMesh.actionManager) {
                                    hit.pickedMesh.actionManager.processTrigger(
                                        BABYLON.ActionManager.OnPickTrigger,
                                        BABYLON.ActionEvent.CreateNew(hit.pickedMesh)
                                    );
                                }
                            }
                        });
                    }

                    // ── LEFT THUMBSTICK: scene navigation + vertical movement
                    // (Right thumbstick is used by Babylon's teleportation system)
                    if (hand === "left") {
                        const thumbstick = mc.getComponent("xr-standard-thumbstick");
                        if (thumbstick) {
                            let navCooldown = false;
                            thumbstick.onAxisValueChangedObservable.add((axes) => {
                                // Left/right: prev/next scene
                                if (Math.abs(axes.x) > 0.7 && !navCooldown) {
                                    navCooldown = true;
                                    if (axes.x > 0.7) qvr.goTo(qvr.currentIndex + 1);
                                    else if (axes.x < -0.7) qvr.goTo(qvr.currentIndex - 1);
                                    setTimeout(() => { navCooldown = false; }, 800);
                                }
                                // Up/down: vertical movement
                                if (Math.abs(axes.y) > 0.3 && xr.baseExperience.camera) {
                                    xr.baseExperience.camera.position.y -= axes.y * VERTICAL_SPEED;
                                }
                            });
                        }

                        // ── X BUTTON (left): toggle info panel
                        const xBtn = mc.getComponent("x-button");
                        if (xBtn) {
                            xBtn.onButtonStateChangedObservable.add((comp) => {
                                if (comp.pressed) {
                                    document.getElementById("info-panel").classList.toggle("hidden");
                                }
                            });
                        }

                        // ── Y BUTTON (left): previous scene
                        const yBtn = mc.getComponent("y-button");
                        if (yBtn) {
                            let yCooldown = false;
                            yBtn.onButtonStateChangedObservable.add((comp) => {
                                if (comp.pressed && !yCooldown) {
                                    yCooldown = true;
                                    qvr.goTo(qvr.currentIndex - 1);
                                    setTimeout(() => { yCooldown = false; }, 1000);
                                }
                            });
                        }
                    }

                    // ── RIGHT HAND
                    if (hand === "right") {
                        // Right thumbstick: left by Babylon for teleportation/snap-turn

                        // ── A BUTTON (right): toggle info panel
                        const aBtn = mc.getComponent("a-button");
                        if (aBtn) {
                            aBtn.onButtonStateChangedObservable.add((comp) => {
                                if (comp.pressed) {
                                    document.getElementById("info-panel").classList.toggle("hidden");
                                }
                            });
                        }

                        // ── B BUTTON (right): next scene
                        const bBtn = mc.getComponent("b-button");
                        if (bBtn) {
                            let bCooldown = false;
                            bBtn.onButtonStateChangedObservable.add((comp) => {
                                if (comp.pressed && !bCooldown) {
                                    bCooldown = true;
                                    qvr.goTo(qvr.currentIndex + 1);
                                    setTimeout(() => { bCooldown = false; }, 1000);
                                }
                            });
                        }
                    }
                });
            });
        };

        qvr.transition = async function (callback) {
            const overlay = document.getElementById("transition-overlay");
            overlay.classList.add("active");
            await new Promise(r => setTimeout(r, 600));
            await callback();
            await new Promise(r => setTimeout(r, 200));
            overlay.classList.remove("active");
        };

        qvr.updateMenu = function () {
            const menu = document.getElementById("scene-menu");
            menu.innerHTML = "";

            const tiers = [
                { label: "Hub", start: 0, end: 1 },
                { label: "Foundations", start: 1, end: 6 },
                { label: "Core Mechanics", start: 6, end: 11 },
                { label: "Gates & Protocols", start: 11, end: 15 },
                { label: "Algorithms", start: 15, end: 19 },
                { label: "Real-World Challenges", start: 19, end: 21 },
                { label: "Future Applications", start: 21, end: 26 },
            ];

            tiers.forEach(tier => {
                if (tier.start >= qvr.scenes.length) return;
                const label = document.createElement("div");
                label.className = "tier-label";
                label.textContent = tier.label;
                menu.appendChild(label);
                for (let i = tier.start; i < Math.min(tier.end, qvr.scenes.length); i++) {
                    const item = document.createElement("div");
                    item.className = "menu-item" + (i === qvr.currentIndex ? " active" : "");
                    item.innerHTML = '<span class="num">' + i + '</span> ' + qvr.scenes[i].title;
                    item.onclick = ((idx) => () => {
                        menu.classList.add("hidden");
                        qvr.goTo(idx);
                    })(i);
                    menu.appendChild(item);
                }
            });
        };

        qvr.goTo = async function (index) {
            if (index < 0 || index >= qvr.scenes.length) return;
            if (index === qvr.currentIndex) return;

            await qvr.transition(async () => {
                // Cleanup old scene
                if (qvr.currentScene) {
                    if (qvr.scenes[qvr.currentIndex] && qvr.scenes[qvr.currentIndex].cleanup) {
                        qvr.scenes[qvr.currentIndex].cleanup();
                    }
                    qvr.currentScene.dispose();
                    qvr.currentScene = null;
                }

                // Create new scene
                const def = qvr.scenes[index];
                const scene = new BABYLON.Scene(engine);
                qvr.currentScene = scene;
                qvr.currentIndex = index;

                // Setup
                await def.setup(scene, qvr);

                // Try WebXR + controller/head interactions
                try {
                    const ground = scene.getMeshByName("ground");
                    if (ground) {
                        qvr.xrHelper = await scene.createDefaultXRExperienceAsync({
                            floorMeshes: [ground],
                            disableTeleportation: false,
                        });
                        qvr.setupXRInteractions(scene, qvr.xrHelper);
                    }
                } catch (e) { /* WebXR not available */ }

                // Update HUD
                document.getElementById("scene-title").textContent = def.title || "";
                document.getElementById("scene-subtitle").textContent = def.subtitle || "";
                document.getElementById("info-title").textContent = def.title || "";
                document.getElementById("info-text").textContent = def.info || "";
                document.getElementById("prevBtn").disabled = index === 0;
                document.getElementById("nextBtn").disabled = index === qvr.scenes.length - 1;

                // Update menu
                qvr.updateMenu();

                // Start render
                engine.stopRenderLoop();
                engine.runRenderLoop(() => scene.render());
            });
        };

        // ── HUD event handlers ─────────────────────────────────
        document.getElementById("prevBtn").onclick = () => qvr.goTo(qvr.currentIndex - 1);
        document.getElementById("nextBtn").onclick = () => qvr.goTo(qvr.currentIndex + 1);

        const menuEl = document.getElementById("scene-menu");
        document.getElementById("menuBtn").onclick = () => menuEl.classList.toggle("hidden");

        const infoPanel = document.getElementById("info-panel");
        document.getElementById("info-toggle").onclick = () => infoPanel.classList.toggle("hidden");

        document.addEventListener("click", (e) => {
            if (!menuEl.contains(e.target) && e.target.id !== "menuBtn") {
                menuEl.classList.add("hidden");
            }
        });

        // Keyboard nav
        document.addEventListener("keydown", (e) => {
            if (e.key === "ArrowRight" || e.key === "n") qvr.goTo(qvr.currentIndex + 1);
            if (e.key === "ArrowLeft" || e.key === "p") qvr.goTo(qvr.currentIndex - 1);
            if (e.key === "i") infoPanel.classList.toggle("hidden");
        });

        // ── Boot ───────────────────────────────────────────────
        window.addEventListener("resize", () => engine.resize());

        console.log("QVR: " + qvr.scenes.length + " scenes registered");
        if (qvr.scenes.length > 0) {
            await qvr.goTo(0);
        }
    })();
    </script>
</body>
</html>
