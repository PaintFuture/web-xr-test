<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Physics Playground</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/babylonjs@8.52.0/babylon.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-loaders@8.52.0/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babylonjs/havok@1.3.11/lib/umd/HavokPhysics_umd.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="ui-overlay">
        <button id="spawnBtn">Spawn Ball</button>
    </div>

    <script>
        (async function () {
            const canvas = document.getElementById("renderCanvas");
            const engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
            });

            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.12, 1);

            // Camera — works for desktop preview and as fallback in VR
            const camera = new BABYLON.FreeCamera(
                "camera",
                new BABYLON.Vector3(0, 3, -8),
                scene
            );
            camera.setTarget(new BABYLON.Vector3(0, 1, 0));
            camera.attachControl(canvas, true);

            // Lighting
            const hemi = new BABYLON.HemisphericLight(
                "hemi",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemi.intensity = 0.6;

            const dir = new BABYLON.DirectionalLight(
                "dir",
                new BABYLON.Vector3(-1, -2, 1),
                scene
            );
            dir.intensity = 0.8;
            dir.position = new BABYLON.Vector3(5, 10, -5);

            // Shadows
            const shadowGen = new BABYLON.ShadowGenerator(1024, dir);
            shadowGen.useBlurExponentialShadowMap = true;

            // ── Havok Physics ──────────────────────────────────
            const havokInstance = await HavokPhysics();
            const havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(
                new BABYLON.Vector3(0, -9.81, 0),
                havokPlugin
            );

            // ── Ground ─────────────────────────────────────────
            const ground = BABYLON.MeshBuilder.CreateGround(
                "ground",
                { width: 20, height: 20 },
                scene
            );
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.3);
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;
            ground.receiveShadows = true;

            new BABYLON.PhysicsAggregate(
                ground,
                BABYLON.PhysicsShapeType.BOX,
                { mass: 0, friction: 0.8, restitution: 0.3 },
                scene
            );

            // ── Helper: random color material ──────────────────
            const palette = [
                new BABYLON.Color3(0.9, 0.2, 0.2),
                new BABYLON.Color3(0.2, 0.7, 0.3),
                new BABYLON.Color3(0.2, 0.4, 0.9),
                new BABYLON.Color3(0.95, 0.7, 0.1),
                new BABYLON.Color3(0.8, 0.3, 0.8),
                new BABYLON.Color3(0.1, 0.8, 0.8),
            ];

            function randomMaterial(prefix) {
                const mat = new BABYLON.StandardMaterial(prefix + "_mat", scene);
                mat.diffuseColor =
                    palette[Math.floor(Math.random() * palette.length)];
                return mat;
            }

            // ── Spawn helpers ──────────────────────────────────
            function spawnBox(position) {
                const size = 0.4 + Math.random() * 0.6;
                const box = BABYLON.MeshBuilder.CreateBox(
                    "box_" + Date.now(),
                    { size },
                    scene
                );
                box.position = position.clone();
                box.material = randomMaterial("box");
                shadowGen.addShadowCaster(box);

                new BABYLON.PhysicsAggregate(
                    box,
                    BABYLON.PhysicsShapeType.BOX,
                    { mass: 1, friction: 0.6, restitution: 0.3 },
                    scene
                );
                return box;
            }

            function spawnBall(position, impulseDir) {
                const radius = 0.2 + Math.random() * 0.3;
                const sphere = BABYLON.MeshBuilder.CreateSphere(
                    "ball_" + Date.now(),
                    { diameter: radius * 2, segments: 16 },
                    scene
                );
                sphere.position = position.clone();
                sphere.material = randomMaterial("ball");
                shadowGen.addShadowCaster(sphere);

                const agg = new BABYLON.PhysicsAggregate(
                    sphere,
                    BABYLON.PhysicsShapeType.SPHERE,
                    { mass: 1, friction: 0.5, restitution: 0.6 },
                    scene
                );

                if (impulseDir) {
                    agg.body.applyImpulse(
                        impulseDir,
                        sphere.getAbsolutePosition()
                    );
                }
                return sphere;
            }

            // ── Initial scene objects ──────────────────────────
            for (let i = 0; i < 6; i++) {
                const x = (Math.random() - 0.5) * 6;
                const z = (Math.random() - 0.5) * 6;
                spawnBox(new BABYLON.Vector3(x, 3 + i * 1.2, z));
            }
            for (let i = 0; i < 4; i++) {
                const x = (Math.random() - 0.5) * 4;
                const z = (Math.random() - 0.5) * 4;
                spawnBall(new BABYLON.Vector3(x, 5 + i * 1.5, z), null);
            }

            // ── Desktop UI: spawn ball button ──────────────────
            document.getElementById("spawnBtn").addEventListener("click", () => {
                const pos = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 4,
                    5,
                    (Math.random() - 0.5) * 4
                );
                spawnBall(pos, null);
            });

            // ── WebXR ──────────────────────────────────────────
            try {
                const xr = await scene.createDefaultXRExperienceAsync({
                    floorMeshes: [ground],
                    disableTeleportation: false,
                });

                // Controller trigger → spawn ball in front of controller
                xr.input.onControllerAddedObservable.add((controller) => {
                    controller.onMotionControllerInitObservable.add((mc) => {
                        const trigger =
                            mc.getComponent("xr-standard-trigger");
                        if (trigger) {
                            trigger.onButtonStateChangedObservable.add(
                                (component) => {
                                    if (component.pressed) {
                                        const pos =
                                            controller.pointer.absolutePosition.clone();
                                        const fwd =
                                            controller.pointer.forward.clone();
                                        // Spawn slightly in front of controller
                                        const spawnPos = pos.add(
                                            fwd.scale(0.3)
                                        );
                                        const impulse = fwd.scale(5);
                                        spawnBall(spawnPos, impulse);
                                    }
                                }
                            );
                        }
                    });
                });

                console.log("WebXR initialized");
            } catch (e) {
                console.warn("WebXR not available:", e.message);
            }

            // ── Render loop ────────────────────────────────────
            engine.runRenderLoop(() => scene.render());
            window.addEventListener("resize", () => engine.resize());
        })();
    </script>
</body>
</html>
