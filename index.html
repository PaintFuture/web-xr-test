<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum VR Explorer</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/babylonjs@8.52.0/babylon.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-loaders@8.52.0/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babylonjs/havok@1.3.11/lib/umd/HavokPhysics_umd.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <div id="transition-overlay"></div>

    <div id="hud">
        <div>
            <div id="scene-title"></div>
            <div id="scene-subtitle"></div>
        </div>
        <div id="nav-buttons">
            <button id="prevBtn" title="Previous scene">&#9664; Prev</button>
            <button id="menuBtn" title="Scene list">&#9776; Scenes</button>
            <button id="nextBtn" title="Next scene">Next &#9654;</button>
        </div>
    </div>

    <div id="info-panel" class="hidden">
        <h3 id="info-title"></h3>
        <p id="info-text"></p>
    </div>
    <button id="info-toggle" class="hud-btn" style="
        padding: 8px 16px; font-size: 14px; border: 1px solid rgba(255,255,255,0.2);
        border-radius: 6px; cursor: pointer; background: rgba(255,255,255,0.1);
        color: #fff; backdrop-filter: blur(6px);
    ">? Info</button>

    <button id="mute-toggle" class="hud-btn" style="
        padding: 8px 12px; font-size: 16px; border: 1px solid rgba(255,255,255,0.2);
        border-radius: 6px; cursor: pointer; background: rgba(255,255,255,0.1);
        color: #fff; backdrop-filter: blur(6px); min-width: 40px;
    " title="Toggle sound">&#x1f50a;</button>

    <div id="scene-menu" class="hidden"></div>

    <!-- Audio system (procedural Web Audio synthesis) -->
    <script src="audio.js"></script>

    <!-- QVR global must exist before scene scripts register against it -->
    <script>
    window.QVR = {
        scenes: [],
        register(def) { this.scenes.push(def); }
    };
    </script>

    <!-- Scene scripts (each calls QVR.register) -->
    <script src="scenes/00-hub.js"></script>
    <script src="scenes/01-bit-vs-qubit.js"></script>
    <script src="scenes/02-superposition.js"></script>
    <script src="scenes/03-measurement.js"></script>
    <script src="scenes/04-bloch-sphere.js"></script>
    <script src="scenes/05-quantum-gates.js"></script>
    <script src="scenes/06-amplitudes-phase.js"></script>
    <script src="scenes/07-interference.js"></script>
    <script src="scenes/08-multi-qubit.js"></script>
    <script src="scenes/09-entanglement.js"></script>
    <script src="scenes/10-quantum-circuits.js"></script>
    <script src="scenes/11-cnot-gate.js"></script>
    <script src="scenes/12-bell-states.js"></script>
    <script src="scenes/13-teleportation.js"></script>
    <script src="scenes/14-no-cloning.js"></script>
    <script src="scenes/15-hadamard-transform.js"></script>
    <script src="scenes/16-grovers-search.js"></script>
    <script src="scenes/17-shors-algorithm.js"></script>
    <script src="scenes/18-qft.js"></script>
    <script src="scenes/19-decoherence.js"></script>
    <script src="scenes/20-error-correction.js"></script>
    <script src="scenes/21-drug-discovery.js"></script>
    <script src="scenes/22-quantum-crypto.js"></script>
    <script src="scenes/23-quantum-ml.js"></script>
    <script src="scenes/24-quantum-internet.js"></script>
    <script src="scenes/25-timeline.js"></script>

    <!-- Boot: attach engine, utilities, and start first scene -->
    <script>
    (async function () {
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true,
        });

        // Extend QVR with engine and utilities now that Babylon is ready
        const qvr = window.QVR;
        qvr.engine = engine;
        qvr.canvas = canvas;
        qvr.currentIndex = -1;
        qvr.currentScene = null;
        qvr.xrHelper = null;

        // ── Shared utilities ───────────────────────────────────

        qvr.createStarfield = function (scene) {
            scene.clearColor = new BABYLON.Color4(0.01, 0.01, 0.04, 1);

            const starParent = new BABYLON.TransformNode("stars", scene);
            const SPS = new BABYLON.SolidParticleSystem("stars", scene, { isPickable: false });
            const starModel = BABYLON.MeshBuilder.CreatePolyhedron("s", { size: 0.02, type: 0 }, scene);
            SPS.addShape(starModel, 1500);
            starModel.dispose();
            const mesh = SPS.buildMesh();
            mesh.parent = starParent;

            SPS.initParticles = () => {
                for (let i = 0; i < SPS.nbParticles; i++) {
                    const p = SPS.particles[i];
                    const r = 30 + Math.random() * 70;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    p.position.x = r * Math.sin(phi) * Math.cos(theta);
                    p.position.y = r * Math.sin(phi) * Math.sin(theta);
                    p.position.z = r * Math.cos(phi);
                    const b = 0.3 + Math.random() * 0.7;
                    p.color = new BABYLON.Color4(b, b, b * 1.1, 1);
                    p.scaling.setAll(0.5 + Math.random() * 2);
                }
            };
            SPS.initParticles();
            SPS.setParticles();
            SPS.isAlwaysVisible = true;

            scene.onBeforeRenderObservable.add(() => {
                starParent.rotation.y += 0.00005;
                starParent.rotation.x += 0.00002;
            });

            const nebulaColors = [
                new BABYLON.Color3(0.15, 0.05, 0.3),
                new BABYLON.Color3(0.05, 0.1, 0.3),
                new BABYLON.Color3(0.2, 0.02, 0.1),
            ];
            for (let i = 0; i < 3; i++) {
                const nebula = BABYLON.MeshBuilder.CreatePlane("nebula" + i, { size: 40 + Math.random() * 30 }, scene);
                nebula.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 40,
                    30 + Math.random() * 40
                );
                nebula.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
                const mat = new BABYLON.StandardMaterial("nebMat" + i, scene);
                mat.emissiveColor = nebulaColors[i];
                mat.disableLighting = true;
                mat.alpha = 0.06 + Math.random() * 0.06;
                nebula.material = mat;
            }
            return starParent;
        };

        qvr.createLighting = function (scene) {
            const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.5;
            hemi.diffuse = new BABYLON.Color3(0.7, 0.75, 1.0);
            const point = new BABYLON.PointLight("point", new BABYLON.Vector3(3, 5, -3), scene);
            point.intensity = 0.8;
            point.diffuse = new BABYLON.Color3(0.9, 0.85, 1.0);
            return { hemi, point };
        };

        qvr.createGlow = function (scene) {
            const gl = new BABYLON.GlowLayer("glow", scene, { blurKernelSize: 32 });
            gl.intensity = 0.6;
            return gl;
        };

        qvr.createQubitSphere = function (name, diameter, color, scene) {
            const sphere = BABYLON.MeshBuilder.CreateSphere(name, { diameter, segments: 32 }, scene);
            const mat = new BABYLON.StandardMaterial(name + "Mat", scene);
            mat.diffuseColor = color;
            mat.emissiveColor = color.scale(0.3);
            mat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.6);
            mat.specularPower = 64;
            sphere.material = mat;
            return sphere;
        };

        qvr.createTextPlane = function (text, fontSize, width, scene) {
            const h = width * 0.35;
            const plane = BABYLON.MeshBuilder.CreatePlane("tp_" + Date.now() + Math.random(), { width, height: h }, scene);
            // Higher res texture for VR readability
            const texW = 1024, texH = Math.round(1024 * 0.35);
            const scaledFont = Math.round(fontSize * (1024 / 512));
            const tex = new BABYLON.DynamicTexture("dt_" + Date.now(), { width: texW, height: texH }, scene);
            const ctx = tex.getContext();
            // Dark background pill for contrast
            const pad = 12;
            ctx.fillStyle = "rgba(5, 5, 20, 0.65)";
            const metrics = (function () {
                ctx.font = "bold " + scaledFont + "px Segoe UI, system-ui, sans-serif";
                return ctx.measureText(text);
            })();
            const bgW = Math.min(metrics.width + pad * 4, texW);
            const bgH = scaledFont + pad * 2;
            const bgX = (texW - bgW) / 2;
            const bgY = (texH - bgH) / 2;
            // Rounded rect
            const r = 10;
            ctx.beginPath();
            ctx.moveTo(bgX + r, bgY);
            ctx.lineTo(bgX + bgW - r, bgY);
            ctx.quadraticCurveTo(bgX + bgW, bgY, bgX + bgW, bgY + r);
            ctx.lineTo(bgX + bgW, bgY + bgH - r);
            ctx.quadraticCurveTo(bgX + bgW, bgY + bgH, bgX + bgW - r, bgY + bgH);
            ctx.lineTo(bgX + r, bgY + bgH);
            ctx.quadraticCurveTo(bgX, bgY + bgH, bgX, bgY + bgH - r);
            ctx.lineTo(bgX, bgY + r);
            ctx.quadraticCurveTo(bgX, bgY, bgX + r, bgY);
            ctx.closePath();
            ctx.fill();
            // Text with stroke for boldness
            ctx.font = "bold " + scaledFont + "px Segoe UI, system-ui, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeStyle = "rgba(0,0,0,0.6)";
            ctx.lineWidth = 3;
            ctx.strokeText(text, texW / 2, texH / 2);
            ctx.fillStyle = "#ffffff";
            ctx.fillText(text, texW / 2, texH / 2);
            tex.update();
            tex.hasAlpha = true;
            const mat = new BABYLON.StandardMaterial("tm_" + Date.now(), scene);
            mat.diffuseTexture = tex;
            mat.emissiveTexture = tex;
            mat.opacityTexture = tex;
            mat.disableLighting = true;
            mat.backFaceCulling = false;
            mat.useAlphaFromDiffuseTexture = true;
            plane.material = mat;
            plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            return plane;
        };

        // ── VR Info Panel (3D plane visible in immersive mode) ──
        qvr.vrInfoPanel = null;
        qvr.vrInfoVisible = false;

        qvr.createVRInfoPanel = function (scene) {
            // Panel: 2m wide, 1m tall, positioned 2.5m in front of user
            const w = 2, h = 1;
            const plane = BABYLON.MeshBuilder.CreatePlane("vrInfoPanel", { width: w, height: h }, scene);
            plane.isPickable = false;

            const texW = 1024, texH = 512;
            const tex = new BABYLON.DynamicTexture("vrInfoTex", { width: texW, height: texH }, scene);
            tex.hasAlpha = true;
            const mat = new BABYLON.StandardMaterial("vrInfoMat", scene);
            mat.diffuseTexture = tex;
            mat.emissiveTexture = tex;
            mat.opacityTexture = tex;
            mat.disableLighting = true;
            mat.backFaceCulling = false;
            mat.useAlphaFromDiffuseTexture = true;
            plane.material = mat;
            plane.setEnabled(false);

            qvr.vrInfoPanel = plane;
            qvr.vrInfoTex = tex;
            return plane;
        };

        qvr.updateVRInfoContent = function (title, text) {
            if (!qvr.vrInfoTex) return;
            const tex = qvr.vrInfoTex;
            const ctx2d = tex.getContext();
            const w = 1024, h = 512;
            ctx2d.clearRect(0, 0, w, h);

            // Background
            ctx2d.fillStyle = "rgba(5, 5, 25, 0.85)";
            const r = 20, pad = 20;
            ctx2d.beginPath();
            ctx2d.moveTo(pad + r, pad);
            ctx2d.lineTo(w - pad - r, pad);
            ctx2d.quadraticCurveTo(w - pad, pad, w - pad, pad + r);
            ctx2d.lineTo(w - pad, h - pad - r);
            ctx2d.quadraticCurveTo(w - pad, h - pad, w - pad - r, h - pad);
            ctx2d.lineTo(pad + r, h - pad);
            ctx2d.quadraticCurveTo(pad, h - pad, pad, h - pad - r);
            ctx2d.lineTo(pad, pad + r);
            ctx2d.quadraticCurveTo(pad, pad, pad + r, pad);
            ctx2d.closePath();
            ctx2d.fill();

            // Border
            ctx2d.strokeStyle = "rgba(100, 140, 255, 0.4)";
            ctx2d.lineWidth = 2;
            ctx2d.stroke();

            // Title
            ctx2d.font = "bold 36px Segoe UI, system-ui, sans-serif";
            ctx2d.fillStyle = "#88aaff";
            ctx2d.textAlign = "left";
            ctx2d.textBaseline = "top";
            ctx2d.fillText(title || "", 50, 50);

            // Body text — word wrap
            ctx2d.font = "26px Segoe UI, system-ui, sans-serif";
            ctx2d.fillStyle = "#ddddef";
            const maxW = w - 100;
            const words = (text || "").split(" ");
            let line = "";
            let y = 100;
            const lineH = 34;
            for (let i = 0; i < words.length; i++) {
                const test = line + words[i] + " ";
                if (ctx2d.measureText(test).width > maxW && line) {
                    ctx2d.fillText(line.trim(), 50, y);
                    line = words[i] + " ";
                    y += lineH;
                    if (y > h - 60) { ctx2d.fillText("...", 50, y); break; }
                } else {
                    line = test;
                }
            }
            if (line && y <= h - 60) ctx2d.fillText(line.trim(), 50, y);

            tex.update();
        };

        qvr.toggleVRInfo = function (scene, xr) {
            if (!qvr.vrInfoPanel) qvr.createVRInfoPanel(scene);
            qvr.vrInfoVisible = !qvr.vrInfoVisible;
            qvr.vrInfoPanel.setEnabled(qvr.vrInfoVisible);

            if (qvr.vrInfoVisible && xr && xr.baseExperience && xr.baseExperience.camera) {
                // Position panel 2.5m in front of user, at eye height
                const cam = xr.baseExperience.camera;
                const fwd = cam.getForwardRay().direction;
                const pos = cam.position.clone().add(fwd.scale(2.5));
                qvr.vrInfoPanel.position = pos;
                qvr.vrInfoPanel.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

                // Update content
                const def = qvr.scenes[qvr.currentIndex];
                if (def) qvr.updateVRInfoContent(def.title, def.info);
            }
        };

        // ── XR Interactions (applied to every scene) ────────
        qvr.setupXRInteractions = function (scene, xr) {
            if (!xr || !xr.baseExperience) return;

            const DEADZONE_DEG = 5;
            const DEADZONE_RAD = DEADZONE_DEG * Math.PI / 180;
            const FLY_SPEED = 0.06;
            const VERTICAL_SPEED = 0.03;

            // ── Head-tilt flying ───────────────────────────────
            // Lean forward (pitch down) > 5° = fly in gaze direction
            // Lean back (pitch up) > 5° = fly backward
            let baseHeadPitch = null;
            let calibrated = false;

            xr.baseExperience.onStateChangedObservable.add((state) => {
                if (state === BABYLON.WebXRState.IN_XR) {
                    // Calibrate after a short delay so user settles
                    setTimeout(() => {
                        calibrated = false; // will calibrate on first frame
                    }, 1000);
                }
            });

            // Head-tilt render callback — stored so it survives scene content clearing
            const headTiltCallback = () => {
                if (!xr.baseExperience.camera) return;
                const cam = xr.baseExperience.camera;

                const rot = cam.rotationQuaternion;
                if (!rot) return;

                const euler = rot.toEulerAngles();
                const pitch = euler.x;

                if (!calibrated) {
                    baseHeadPitch = pitch;
                    calibrated = true;
                    return;
                }

                const deltaPitch = pitch - baseHeadPitch;

                if (Math.abs(deltaPitch) > DEADZONE_RAD) {
                    const intensity = (Math.abs(deltaPitch) - DEADZONE_RAD) * 3;
                    const speed = Math.min(intensity, 1) * FLY_SPEED;
                    const direction = deltaPitch < 0 ? -1 : 1;

                    const forward = cam.getForwardRay().direction;
                    forward.y = 0;
                    forward.normalize();

                    const move = forward.scale(direction * speed);
                    cam.position.addInPlace(move);
                }
            };
            scene.onBeforeRenderObservable.add(headTiltCallback);
            // Store for preservation across scene changes
            if (!qvr._xrRenderCallbacks) qvr._xrRenderCallbacks = [];
            qvr._xrRenderCallbacks.push(headTiltCallback);

            // ── Controller interactions ────────────────────────
            // Pico 4 Ultra profile: pico-4u
            // Left:  trigger, squeeze, thumbstick, x-button, y-button
            // Right: trigger, squeeze, thumbstick, a-button, b-button

            // Start audio when entering XR
            xr.baseExperience.onStateChangedObservable.add((state) => {
                if (state === BABYLON.WebXRState.IN_XR) ensureAudio();
            });

            xr.input.onControllerAddedObservable.add((controller) => {
                controller.onMotionControllerInitObservable.add((mc) => {
                    const hand = mc.handedness; // "left" or "right"

                    // ── BOTH HANDS — SQUEEZE (GRIP): spawn quantum particle + muzzle flash
                    const squeeze = mc.getComponent("xr-standard-squeeze");
                    if (squeeze) {
                        let squeezeWasPressed = false;
                        squeeze.onButtonStateChangedObservable.add((comp) => {
                            // Use value threshold instead of pressed — more reliable across runtimes
                            const isDown = comp.value > 0.8 || comp.pressed;
                            if (isDown && !squeezeWasPressed) {
                                squeezeWasPressed = true;
                                QAudio.playParticleSpawn();
                                const pos = controller.pointer.absolutePosition.clone();
                                const fwd = controller.pointer.forward.clone();
                                const spawnPos = pos.add(fwd.scale(0.3));

                                // Muzzle flash
                                const flash = BABYLON.MeshBuilder.CreateSphere("flash", {diameter:0.15, segments:6}, scene);
                                flash.position = spawnPos.clone();
                                const fMat = new BABYLON.StandardMaterial("fMat", scene);
                                fMat.emissiveColor = new BABYLON.Color3(1,0.8,0.3);
                                fMat.disableLighting = true;
                                flash.material = fMat;
                                let life = 1;
                                const obs = scene.onBeforeRenderObservable.add(() => {
                                    life -= 0.08;
                                    flash.scaling.setAll(life);
                                    fMat.alpha = life;
                                    if (life <= 0) {
                                        scene.onBeforeRenderObservable.remove(obs);
                                        flash.dispose(); fMat.dispose();
                                    }
                                });

                                // Quantum particle
                                const particle = BABYLON.MeshBuilder.CreateSphere("qp", {diameter:0.2, segments:12}, scene);
                                particle.position = spawnPos.clone();
                                const pMat = new BABYLON.StandardMaterial("qpMat", scene);
                                const hue = Math.random();
                                pMat.diffuseColor = new BABYLON.Color3(
                                    0.3+hue*0.7, 0.3+(1-hue)*0.5, 0.8
                                );
                                pMat.emissiveColor = pMat.diffuseColor.scale(0.4);
                                particle.material = pMat;

                                const vel = fwd.scale(0.15);
                                let pLife = 1;
                                const pObs = scene.onBeforeRenderObservable.add(() => {
                                    particle.position.addInPlace(vel);
                                    vel.scaleInPlace(0.98);
                                    pLife -= 0.008;
                                    pMat.alpha = pLife;
                                    particle.scaling.setAll(0.5 + (1-pLife)*0.5);
                                    if (pLife <= 0) {
                                        scene.onBeforeRenderObservable.remove(pObs);
                                        particle.dispose(); pMat.dispose();
                                    }
                                });
                            } else if (!isDown) {
                                squeezeWasPressed = false;
                            }
                        });
                    }

                    // ── BOTH HANDS — TRIGGER: ray-pick interact + spawn particle
                    const trigger = mc.getComponent("xr-standard-trigger");
                    if (trigger) {
                        trigger.onButtonStateChangedObservable.add((comp) => {
                            if (comp.pressed) {
                                const ray = new BABYLON.Ray(
                                    controller.pointer.absolutePosition,
                                    controller.pointer.forward,
                                    20
                                );
                                const hit = scene.pickWithRay(ray);
                                if (hit && hit.pickedMesh && hit.pickedMesh.actionManager) {
                                    QAudio.playClick();
                                    hit.pickedMesh.actionManager.processTrigger(
                                        BABYLON.ActionManager.OnPickTrigger,
                                        BABYLON.ActionEvent.CreateNew(hit.pickedMesh)
                                    );
                                } else {
                                    // No interactive object hit — shoot a particle
                                    QAudio.playParticleSpawn();
                                    const pos = controller.pointer.absolutePosition.clone();
                                    const fwd = controller.pointer.forward.clone();
                                    const sp = pos.add(fwd.scale(0.3));

                                    const p = BABYLON.MeshBuilder.CreateSphere("tp", {diameter:0.15, segments:8}, scene);
                                    p.position = sp;
                                    const pm = new BABYLON.StandardMaterial("tpm", scene);
                                    const h = Math.random();
                                    pm.diffuseColor = new BABYLON.Color3(0.3+h*0.7, 0.3+(1-h)*0.5, 0.8);
                                    pm.emissiveColor = pm.diffuseColor.scale(0.5);
                                    p.material = pm;

                                    const v = fwd.scale(0.12);
                                    let l = 1;
                                    const ob = scene.onBeforeRenderObservable.add(() => {
                                        p.position.addInPlace(v);
                                        v.scaleInPlace(0.97);
                                        l -= 0.01;
                                        pm.alpha = l;
                                        if (l <= 0) { scene.onBeforeRenderObservable.remove(ob); p.dispose(); pm.dispose(); }
                                    });
                                }
                            }
                        });
                    }

                    // ── LEFT THUMBSTICK: scene navigation + vertical movement
                    // (Right thumbstick is used by Babylon's teleportation system)
                    if (hand === "left") {
                        const thumbstick = mc.getComponent("xr-standard-thumbstick");
                        if (thumbstick) {
                            let navCooldown = false;
                            thumbstick.onAxisValueChangedObservable.add((axes) => {
                                // Left/right: prev/next scene
                                if (Math.abs(axes.x) > 0.7 && !navCooldown) {
                                    navCooldown = true;
                                    if (axes.x > 0.7) qvr.goTo(qvr.currentIndex + 1);
                                    else if (axes.x < -0.7) qvr.goTo(qvr.currentIndex - 1);
                                    setTimeout(() => { navCooldown = false; }, 800);
                                }
                                // Up/down: vertical movement
                                if (Math.abs(axes.y) > 0.3 && xr.baseExperience.camera) {
                                    xr.baseExperience.camera.position.y -= axes.y * VERTICAL_SPEED;
                                }
                            });
                        }

                        // ── X BUTTON (left): toggle VR info panel
                        const xBtn = mc.getComponent("x-button");
                        if (xBtn) {
                            xBtn.onButtonStateChangedObservable.add((comp) => {
                                if (comp.pressed) {
                                    QAudio.playPing();
                                    qvr.toggleVRInfo(scene, xr);
                                }
                            });
                        }

                        // ── Y BUTTON (left): previous scene
                        const yBtn = mc.getComponent("y-button");
                        if (yBtn) {
                            let yCooldown = false;
                            yBtn.onButtonStateChangedObservable.add((comp) => {
                                if (comp.pressed && !yCooldown) {
                                    yCooldown = true;
                                    qvr.goTo(qvr.currentIndex - 1);
                                    setTimeout(() => { yCooldown = false; }, 1000);
                                }
                            });
                        }
                    }

                    // ── RIGHT HAND
                    if (hand === "right") {
                        // Right thumbstick: left by Babylon for teleportation/snap-turn

                        // ── A BUTTON (right): toggle VR info panel
                        const aBtn = mc.getComponent("a-button");
                        if (aBtn) {
                            aBtn.onButtonStateChangedObservable.add((comp) => {
                                if (comp.pressed) {
                                    QAudio.playPing();
                                    qvr.toggleVRInfo(scene, xr);
                                }
                            });
                        }

                        // ── B BUTTON (right): next scene
                        const bBtn = mc.getComponent("b-button");
                        if (bBtn) {
                            let bCooldown = false;
                            bBtn.onButtonStateChangedObservable.add((comp) => {
                                if (comp.pressed && !bCooldown) {
                                    bCooldown = true;
                                    qvr.goTo(qvr.currentIndex + 1);
                                    setTimeout(() => { bCooldown = false; }, 1000);
                                }
                            });
                        }
                    }
                });
            });
        };

        qvr.transition = async function (callback) {
            const inXR = qvr.xrHelper && qvr.xrHelper.baseExperience &&
                         qvr.xrHelper.baseExperience.state === BABYLON.WebXRState.IN_XR;

            if (inXR) {
                // In VR: quick transition, no HTML overlay (invisible in XR anyway)
                QAudio.playTransition();
                await new Promise(r => setTimeout(r, 150));
                await callback();
                QAudio.playSceneChime();
            } else {
                // Desktop: use overlay fade
                const overlay = document.getElementById("transition-overlay");
                overlay.classList.add("active");
                QAudio.playTransition();
                await new Promise(r => setTimeout(r, 600));
                await callback();
                QAudio.playSceneChime();
                await new Promise(r => setTimeout(r, 200));
                overlay.classList.remove("active");
            }
        };

        qvr.updateMenu = function () {
            const menu = document.getElementById("scene-menu");
            menu.innerHTML = "";

            const tiers = [
                { label: "Hub", start: 0, end: 1 },
                { label: "Foundations", start: 1, end: 6 },
                { label: "Core Mechanics", start: 6, end: 11 },
                { label: "Gates & Protocols", start: 11, end: 15 },
                { label: "Algorithms", start: 15, end: 19 },
                { label: "Real-World Challenges", start: 19, end: 21 },
                { label: "Future Applications", start: 21, end: 26 },
            ];

            tiers.forEach(tier => {
                if (tier.start >= qvr.scenes.length) return;
                const label = document.createElement("div");
                label.className = "tier-label";
                label.textContent = tier.label;
                menu.appendChild(label);
                for (let i = tier.start; i < Math.min(tier.end, qvr.scenes.length); i++) {
                    const item = document.createElement("div");
                    item.className = "menu-item" + (i === qvr.currentIndex ? " active" : "");
                    item.innerHTML = '<span class="num">' + i + '</span> ' + qvr.scenes[i].title;
                    item.onclick = ((idx) => () => {
                        menu.classList.add("hidden");
                        qvr.goTo(idx);
                    })(i);
                    menu.appendChild(item);
                }
            });
        };

        // Clear scene content without disposing the scene itself.
        // Preserves XR session, camera, and render loop.
        qvr.clearSceneContent = function (scene) {
            // Collect meshes/lights/materials to dispose (skip XR internals)
            const xrMeshNames = new Set(["BackgroundHelper", "BackgroundPlane", "BackgroundSkybox"]);
            const meshes = scene.meshes.slice();
            for (let i = 0; i < meshes.length; i++) {
                const m = meshes[i];
                if (xrMeshNames.has(m.name)) continue;
                // Skip XR controller/pointer meshes
                if (m.name.indexOf("webxr") !== -1 || m.name.indexOf("pointer") !== -1) continue;
                m.dispose(false, true);
            }
            const lights = scene.lights.slice();
            for (let i = 0; i < lights.length; i++) lights[i].dispose();
            const transforms = scene.transformNodes.slice();
            for (let i = 0; i < transforms.length; i++) {
                if (transforms[i].name.indexOf("webxr") !== -1) continue;
                transforms[i].dispose();
            }
            // Clear particle systems
            const particles = scene.particleSystems.slice();
            for (let i = 0; i < particles.length; i++) particles[i].dispose();
            // Clear glow layers
            if (scene.effectLayers) {
                const effects = scene.effectLayers.slice();
                for (let i = 0; i < effects.length; i++) effects[i].dispose();
            }
            // Clear scene-specific render observers but preserve XR ones.
            if (qvr._xrRenderCallbacks) {
                const callbacks = qvr._xrRenderCallbacks.slice();
                scene.onBeforeRenderObservable.clear();
                // Re-register XR callbacks
                callbacks.forEach(function(cb) {
                    scene.onBeforeRenderObservable.add(cb);
                });
            } else {
                scene.onBeforeRenderObservable.clear();
            }
        };

        qvr.goTo = async function (index) {
            if (index < 0 || index >= qvr.scenes.length) return;
            if (index === qvr.currentIndex) return;

            const isFirstLoad = !qvr.currentScene;
            const wasInXR = qvr.xrHelper && qvr.xrHelper.baseExperience &&
                            qvr.xrHelper.baseExperience.state === BABYLON.WebXRState.IN_XR;

            await qvr.transition(async () => {
                // Reset VR info panel state
                qvr.vrInfoPanel = null;
                qvr.vrInfoTex = null;
                qvr.vrInfoVisible = false;

                const def = qvr.scenes[index];

                if (isFirstLoad) {
                    // First load: create scene + XR from scratch
                    const scene = new BABYLON.Scene(engine);
                    qvr.currentScene = scene;
                    qvr.currentIndex = index;

                    await def.setup(scene, qvr);

                    try {
                        const ground = scene.getMeshByName("ground");
                        if (ground) {
                            qvr.xrHelper = await scene.createDefaultXRExperienceAsync({
                                floorMeshes: [ground],
                                disableTeleportation: false,
                            });
                            qvr.setupXRInteractions(scene, qvr.xrHelper);
                        }
                    } catch (e) { /* WebXR not available */ }

                    engine.stopRenderLoop();
                    engine.runRenderLoop(() => scene.render());
                } else {
                    // Subsequent loads: clear content, rebuild in same scene
                    const scene = qvr.currentScene;

                    // Run old scene cleanup if defined
                    if (qvr.scenes[qvr.currentIndex] && qvr.scenes[qvr.currentIndex].cleanup) {
                        qvr.scenes[qvr.currentIndex].cleanup();
                    }

                    qvr.currentIndex = index;

                    // Detach old cameras before clearing
                    const cams = scene.cameras.slice();
                    for (let i = 0; i < cams.length; i++) {
                        // Keep XR cameras
                        if (cams[i].name.indexOf("webxr") !== -1 || cams[i].name.indexOf("WebXR") !== -1) continue;
                        cams[i].detachControl();
                        cams[i].dispose();
                    }

                    qvr.clearSceneContent(scene);

                    // Rebuild scene content
                    await def.setup(scene, qvr);

                    // Update XR floor mesh for teleportation
                    if (qvr.xrHelper && qvr.xrHelper.teleportation) {
                        const ground = scene.getMeshByName("ground");
                        if (ground) {
                            try {
                                qvr.xrHelper.teleportation.removeFloorMeshByName("ground");
                            } catch(e) {}
                            qvr.xrHelper.teleportation.addFloorMesh(ground);
                        }
                    }
                }

                // Update HUD
                document.getElementById("scene-title").textContent = def.title || "";
                document.getElementById("scene-subtitle").textContent = def.subtitle || "";
                document.getElementById("info-title").textContent = def.title || "";
                document.getElementById("info-text").textContent = def.info || "";
                document.getElementById("prevBtn").disabled = index === 0;
                document.getElementById("nextBtn").disabled = index === qvr.scenes.length - 1;

                // Update menu
                qvr.updateMenu();
            });
        };

        // ── Audio init (requires user gesture) ─────────────────
        let audioStarted = false;
        function ensureAudio() {
            if (audioStarted) { QAudio.resume(); return; }
            audioStarted = true;
            QAudio.init();
            QAudio.startAmbient();
        }
        // Start audio on first click/touch/XR session
        const startAudioOnce = () => { ensureAudio(); document.removeEventListener("click", startAudioOnce); document.removeEventListener("touchstart", startAudioOnce); };
        document.addEventListener("click", startAudioOnce);
        document.addEventListener("touchstart", startAudioOnce);

        // Mute toggle
        const muteBtn = document.getElementById("mute-toggle");
        muteBtn.onclick = (e) => {
            e.stopPropagation();
            ensureAudio();
            QAudio.toggleMute();
            muteBtn.innerHTML = QAudio.isMuted() ? "&#x1f507;" : "&#x1f50a;";
        };

        // ── HUD event handlers ─────────────────────────────────
        document.getElementById("prevBtn").onclick = () => qvr.goTo(qvr.currentIndex - 1);
        document.getElementById("nextBtn").onclick = () => qvr.goTo(qvr.currentIndex + 1);

        const menuEl = document.getElementById("scene-menu");
        document.getElementById("menuBtn").onclick = () => { menuEl.classList.toggle("hidden"); QAudio.playPing(); };

        const infoPanel = document.getElementById("info-panel");
        document.getElementById("info-toggle").onclick = () => { infoPanel.classList.toggle("hidden"); QAudio.playPing(); };

        document.addEventListener("click", (e) => {
            if (!menuEl.contains(e.target) && e.target.id !== "menuBtn") {
                menuEl.classList.add("hidden");
            }
        });

        // Keyboard nav
        document.addEventListener("keydown", (e) => {
            if (e.key === "ArrowRight" || e.key === "n") qvr.goTo(qvr.currentIndex + 1);
            if (e.key === "ArrowLeft" || e.key === "p") qvr.goTo(qvr.currentIndex - 1);
            if (e.key === "i") infoPanel.classList.toggle("hidden");
            if (e.key === "m") muteBtn.click();
        });

        // ── Boot ───────────────────────────────────────────────
        window.addEventListener("resize", () => engine.resize());

        console.log("QVR: " + qvr.scenes.length + " scenes registered");
        if (qvr.scenes.length > 0) {
            await qvr.goTo(0);
        }
    })();
    </script>
</body>
</html>
